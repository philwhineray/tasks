#!/usr/bin/env python3

import os
import re
import subprocess
import sys
import tempfile

from GoogleTasks import GoogleTasks
import Matcher
import Project
import Task

help = """
Usage: task COMMAND [OPTION...] WORDS...

task - task management via google task api

COMMAND:
    list   - List tasks
    add    - Add a task
    rename - Rename task
    done   - Mark as complete
    undo   - Mark as incomplete
    delete - Remove task
    edit   - Edit task
    bulk   - Bulk move / re-order tasks

OPTION:
    -P or -p        - Operate at whole-project level
    -f              - Apply operation without confirmation
    -v              - Verbose (e.g. include notes in list)
    -a              - All (e.g. include completed tasks in list)
    --              - No more simple word matchers follow (e.g. for rename)

WORD:
    Numeric: task ID
    WORD:    regexp
    @TAG:    a tag
    due:TIME        - A due date (also d:TIME)
    project:PROJECT - Work on PROJECT (also p:PROJECT)
"""

optionMap = {
      "-P": "project",
      "-p": "project",
      "-f": "force",
      "-v": "verbose",
      "-a": "all",
      "-z": "debug",
      "-zm": "debugMatching",
      "-h": "help",
      }

def main( argv ):
   # Cleanup up automatically on Ctrl-C
   tempdir = tempfile.TemporaryDirectory( prefix = "task-" )

   configDir = os.environ[ 'HOME' ] + '/.config/tasks'
   cacheDir = os.environ[ 'HOME' ] + '/.cache/tasks'
   appCredentialsFile = configDir + GoogleTasks.appCredentialsFileName

   if not os.path.exists( configDir ):
      os.makedirs( configDir )
   if not os.path.exists( cacheDir ):
      os.makedirs( cacheDir )
   if not os.path.exists( appCredentialsFile ):
      raise RuntimeError( "no credentials file - see README.md#app-authentication",
                          appCredentialsFile )

   options = {}
   words = []
   criteria = Matcher.And()
   command = None
   args = { "tempdir" : tempdir.name }

   commandMap = {
         "add" : doTaskAdd,
         "list" : doTaskList,
         "edit" : doTaskEdit,
         "bulk" : doTasksBulk,
         "rename" : doTaskRename,
         "done" : doTaskDone,
         "undo" : doTaskUndo,
         "tag" : doTaskTag,
         "delete" : doTaskDelete,
         "project-add" : doProjectAdd,
         "project-list" : doProjectList,
         "project-rename" : doProjectRename,
         "project-delete" : doProjectDelete,
         }

   aliasMap = {
         "list" : [ "ls" ],
         "delete" : [ "rm", "del" ],
         "rename" : [ "mv" ],
         "project-list" : [ "project-ls" ],
         "project-delete" : [ "project-rm", "project-del" ],
         "project-rename" : [ "project-mv" ]
         }

   for commandToAlias, aliasList in aliasMap.items():
      for alias in aliasList:
         commandMap[ alias ] = commandMap[ commandToAlias ]

   argv = []
   wordMatchersComplete = False
   for arg in sys.argv:
      if wordMatchersComplete:
         argv.append( arg )
         continue

      if re.match( r"-", arg ):
         if arg == "--":
            wordMatchersComplete = True
            argv.append( arg )
         elif arg in optionMap:
            options[ optionMap[ arg ] ] = True
         else:
            print( "warning: option not recognised: %s" % arg, file=sys.stderr )
      else:
         argv.append( arg )

   if not argv:
      print( help )
      return 0

   command = argv.pop( 0 )
   wordMatchersComplete = command == "add"
   criteria.debug = "debugMatching" in options

   for arg in argv:
      if arg == '--':
         wordMatchersComplete = True
      elif arg == 'or' or arg == 'OR':
         if isinstance( criteria.parent, Matcher.Or ):
            orCriteria = criteria.parent
         else:
            orCriteria = Matcher.Or()
            orCriteria.debug = "debugMatching" in options
            orCriteria.add( criteria )
         criteria = Matcher.And()
         orCriteria.add(criteria )
      elif re.match( r"d(ue)?:", arg ):
         criteria.add( Task.DueMatcher( arg[ arg.index( ":" )+1 : ] ) )
      elif re.match( r"p(roject)?:", arg ):
         criteria.add( Project.WordMatcher( arg[ arg.index( ":" )+1 : ] ) )
      elif wordMatchersComplete:
         words.append( arg )
      elif "project" in options:
         criteria.add( Project.WordMatcher( arg ) )
      else:
         criteria.add( Task.WordMatcher( arg ) )

   while criteria.parent:
      criteria = criteria.parent

   if "project" in options and not re.match( "project-", command ):
      command = "project-" + command

   if command not in commandMap:
      print( help )
      if command:
         print( "error: no such command: %s" % command, file=sys.stderr )
      return 1

   if "help" in options:
      # TODO - per-command help
      print( help )
      return 0

   taskApi = GoogleTasks( configDir, cacheDir )
   taskApi.authenticate()

   commandMap[ command ]( taskApi, options, criteria, words, args )

def getMatchingProjects( taskApi, options, criteria ):
   ( projectCriteria, _taskCriteria ) = splitCriteria( criteria )
   projects = taskApi.getProjects()
   match = []
   for project in projects:
      if "debugMatching" in options:
         print( "", file=sys.stderr )
         print( "Matching...", project, file=sys.stderr )
      if criteria.match( project ):
         if "debugMatching" in options:
            print( "%s:" % project.shortId, project.apiObject, file=sys.stderr )
         match.append( project )
   return match

def getMatchingProject( taskApi, options, criteria ):
   match = getMatchingProjects( taskApi, options, criteria )
   if len( match ) != 1:
      raise RuntimeError( "Matched %d project(s)" % len( match ) )
   return match[ 0 ]

def getMatchingTasks( taskApi, options, criteria ):
   projects = taskApi.getProjects()
   tasks = taskApi.getTasks( projects )
   if "all" in options and "onlyComplete" in options:
      raise RuntimeError( "Cannot combine options all and onlyComplete" )
   if "onlyComplete" in options:
      tasks = [ task for task in tasks if task.complete ]
   elif not "all" in options:
      tasks = [ task for task in tasks if not task.complete ]
   match = []
   for task in tasks:
      if "debugMatching" in options:
         print( "", file=sys.stderr )
         print( "Matching...", task, file=sys.stderr )
      if criteria.match( task ):
         if "debugMatching" in options:
            print( "%s:" % task.shortId, task.projectId, task.apiObject, file=sys.stderr )
         match.append( task )
   return match

def getMatchingTask( taskApi, options, criteria ):
   tasks = getMatchingTasks( taskApi, options, criteria )
   if len( tasks ) != 1:
      raise RuntimeError( "Matched %d task(s)" % len( tasks ) )
   return tasks[ 0 ]

def printTasksInProjects( projects, tasks, options, outfile=sys.stdout ):
   if projects is None:
      projects = set( task.project for task in tasks )
   for i, project in enumerate( Project.sort( projects ) ):
      if i > 0: print( "", file=outfile )
      project.print( options=options, outfile=outfile )
      # Ensure items with due dates are at the top and in order
      for task in Task.sort( tasks ):
         if task.project.title == project.title:
            task.print( options=options, outfile=outfile )

def splitCriteria( criteria ):
   projectCriteria = set()
   taskCriteria = set()
   for criterion in criteria.matchers:
      if isinstance( criterion, Project.ProjectMatcher ):
         projectCriteria.add( criterion )
      else:
         taskCriteria.add( criterion )
   return projectCriteria, taskCriteria

def doTaskAdd( taskApi, options, criteria, words, args ):
   ( projectCriteria, taskCriteria ) = splitCriteria( criteria )
   if not projectCriteria:
      projectCriteria = [ Project.WordMatcher( "inbox" ) ]
   if taskCriteria:
      raise RuntimeError( "Cannot use task criteria with 'add'" )
   project = getMatchingProject( taskApi, options, criteria )
   task = Task.Task( project, " ".join( words ) )
   taskApi.addTask( task )

def doTaskList( taskApi, options, criteria, words, args ):
   tasks = getMatchingTasks( taskApi, options, criteria )
   printTasksInProjects( None, tasks, options )

def doTaskRename( taskApi, options, criteria, words, args ):
   task = getMatchingTask( taskApi, options, criteria )
   if not words:
      raise RuntimeError( "No new title given (use -- to complete criteria)" )
   task.title = ' '.join( words )
   task.save()

def doTaskEdit( taskApi, options, criteria, words, args ):
   task = getMatchingTask( taskApi, options, criteria )
   raise NotImplementedError( "doTasksEdit" )

def doTaskTag( taskApi, options, criteria, words, args ):
   task = getMatchingTask( taskApi, options, criteria )
   # TODO: Add @TAG criteria, remove @-TAG criteria
   raise NotImplementedError( "doTasksEdit" )

def doTasksBulk( taskApi, options, criteria, words, args ):
   ( projectCriteria, taskCriteria ) = splitCriteria( criteria )
   if options or taskCriteria:
      raise RuntimeError( "bulk: takes no options or task criteria" )
   projects = getMatchingProjects( taskApi, options, criteria )
   tasks = getMatchingTasks( taskApi, options, criteria )
   taskById = {}
   for task in tasks:
      taskById[ task.shortId ] = task
   projectByName = {}
   for project in projects:
      projectByName[ project.title ] = project
   taskFilePath = args[ 'tempdir' ] + '/tasks.txt'
   taskFile = open( taskFilePath, 'w')
   with open( taskFilePath, 'w' ) as taskFile:
      printTasksInProjects( projects, tasks, options, outfile=taskFile  )
   subprocess.run( [ os.environ.get( 'EDITOR', 'vi' ), taskFilePath ] )
   toSave = set()
   with open( taskFilePath, 'r' ) as taskFile:
      project = None
      for line in taskFile:
         match = re.match( r"(t[0-9a-f]+) +\[([ X-])\] +(\[([0-9-]+)\] +)?(.*)", line )
         if match:
            taskId = match[ 1 ]
            complete = match[ 2 ] == 'X'
            delete = match[ 2 ] == '-'
            date = match[ 4 ]
            title = match[ 5 ]

            task = taskById[ taskId ]
            if delete:
               task.delete()
            if complete:
               task.complete = True
               toSave.add( task )
            if task.title != title:
               task.title = title
               toSave.add( task )
            if task.project.title != project.title:
               if "due" in task.apiObject:
                  print( "Warning: possible loss of time/repeat:",
                         task.lineString() )
               task.project = project
               toSave.add( task )
            # TODO edit task date?
         elif re.match( r"[A-Za-z0-9_]", line ):
            project = projectByName[ line.strip() ]
   for task in toSave:
      task.save()

def doTaskDone( taskApi, options, criteria, words, args ):
   task = getMatchingTask( taskApi, options, criteria )
   task.complete = True
   task.save()
   task.print( options=options )

def doTaskUndo( taskApi, options, criteria, words, args ):
   options[ "onlyComplete" ] = True
   task = getMatchingTask( taskApi, options, criteria )
   task.complete = False
   task.save()
   task.print( options=options )

def doTaskDelete( taskApi, options, criteria, words, args ):
   task = getMatchingTask( taskApi, options, criteria )
   task.print( options=options )
   task.delete()

def doProjectAdd( taskApi, options, criteria, words, args ):
   project = Project.Project( ' '.join( words ) )
   taskApi.addProject( project )

def doProjectList( taskApi, options, criteria, words, args ):
   projects = getMatchingProjects( taskApi, options, criteria )
   for project in projects:
      if "debug" in options:
         print( "%s:" % project.shortId, project.apiObject, file=sys.stderr )
      else:
         print( "%s:" % project.shortId, project )

def doProjectRename( taskApi, options, criteria, words, args ):
   project = getMatchingProject( taskApi, options, criteria )
   if len( words ) < 1:
      raise RuntimeError( "No new name given" )
   project.title = ' '.join( words )
   project.save()

def doProjectDelete( taskApi, options, criteria, words, args ):
   def delProject( project, force ):
      if not force:
         print( "delete %s: %s? [y/N]" % ( project.shortId, project ), file=sys.stderr )
         return
      project.delete()
      print( "deleted: %s: %s" % ( project.shortId, project ), file=sys.stderr )

   ( projectCriteria, taskCriteria ) = splitCriteria( criteria )
   if not projectCriteria:
      raise RuntimeError( "must specify project id(s) or name(s)" )
   if taskCriteria:
      raise RuntimeError( "Cannot use task criteria with 'project-delete'" )
   projects = getMatchingProjects( taskApi, options, criteria )
   titles = set( [ p.title for p in projects ] )
   for project in projects:
      if project.title in titles:
         delProject( project, "force" in options )

if __name__ == '__main__':
   program = sys.argv.pop( 0 )
   status = main( sys.argv )
   if not status:
      status = 0
   sys.exit( status )
