#!/usr/bin/env python3

import os
import re
import subprocess
import sys
import tempfile

from GoogleTasks import GoogleTasks
import Project
import Task

help = """
Usage: task COMMAND [OPTION...] WORDS...

task - task management via google task api

COMMAND:
    list   - List tasks
    add    - Add a task
    rename - Rename task
    done   - Mark as complete
    undo   - Mark as incomplete
    delete - Remove task
    edit   - Edit task
    order  - Bulk move / re-order tasks

OPTION:
    @TAG            - A tag
    due:TIME        - A due date (also d:TIME)
    project:PROJECT - Work on PROJECT, rather than the default (also p:PROJECT)
    -P or -p        - Operate at whole-project level
    -f              - Apply operation without confirmation
    -v              - Verbose (e.g. include notes in list)
    -a              - All (e.g. include completed tasks in list)
    --              - No more simple word matchers follow (e.g. for rename)

WORD:
    Numeric: task ID
    +WORD:   regexp
"""

optionMap = {
      "-P": "project",
      "-p": "project",
      "-f": "force",
      "-v": "verbose",
      "-a": "all",
      "-z": "debug",
      "-h": "help",
      }

def main( argv ):
   # Cleanup up automatically on Ctrl-C
   tempdir = tempfile.TemporaryDirectory( prefix = "task-" )

   configDir = os.environ[ 'HOME' ] + '/.config/tasks'
   cacheDir = os.environ[ 'HOME' ] + '/.cache/tasks'
   appCredentialsFile = configDir + GoogleTasks.appCredentialsFileName

   if not os.path.exists( configDir ):
      os.makedirs( configDir )
   if not os.path.exists( cacheDir ):
      os.makedirs( cacheDir )
   if not os.path.exists( appCredentialsFile ):
      raise RuntimeError( "no credentials file - see README.md#app-authentication",
                          appCredentialsFile )

   options = {}
   tags = set()
   words = []
   criteria = []
   command = None
   projectCriteria = set()
   args = { "tempdir" : tempdir.name }

   commandMap = {
         "add" : doTaskAdd,
         "list" : doTaskList,
         "edit" : doTaskEdit,
         "order" : doTasksOrder,
         "rename" : doTaskRename,
         "done" : doTaskDone,
         "undo" : doTaskUndo,
         "tag" : doTaskTag,
         "delete" : doTaskDelete,
         "project-add" : doProjectAdd,
         "project-list" : doProjectList,
         "project-rename" : doProjectRename,
         "project-delete" : doProjectDelete,
         }

   aliasMap = {
         "list" : [ "ls" ],
         "delete" : [ "rm", "del" ],
         "rename" : [ "mv" ],
         "project-list" : [ "project-ls" ],
         "project-delete" : [ "project-rm", "project-del" ],
         "project-rename" : [ "project-mv" ]
         }

   for commandToAlias, aliasList in aliasMap.items():
      for alias in aliasList:
         commandMap[ alias ] = commandMap[ commandToAlias ]

   wordMatchersComplete = False
   for arg in sys.argv:
      if re.match( r"-", arg ):
         if arg == "--":
            wordMatchersComplete = True
         elif arg in optionMap:
            options[ optionMap[ arg ] ] = True
         else:
            print( "warning: option not recognised: %s" % arg, file=sys.stderr )
      elif arg[ 0 ] == '+':
         tags.put( arg[ 1: ] )
      elif re.match( r"d(ue)?:", arg ):
         criteria.append( Task.DueMatcher( arg[ arg.index( ":" )+1 : ] ) )
      elif re.match( r"p(roject)?:", arg ):
         projectCriteria.add( Project.WordMatcher( arg[ arg.index( ":" )+1 : ] ) )
      elif command:
         if wordMatchersComplete:
            words.append( arg )
         else:
            criteria.append( Task.WordMatcher( arg ) )
      else:
         command = arg
         if command == "add":
            wordMatchersComplete = True

   if "project" in options and not re.match( "project-", command ):
      command = "project-" + command

   if command not in commandMap:
      print( help )
      if command:
         print( "error: no such command: %s" % command, file=sys.stderr )
      return 1

   if "help" in options:
      # TODO - per-command help
      print( help )
      return 0

   taskApi = GoogleTasks( configDir, cacheDir )
   taskApi.authenticate()

   # TODO when we have boolean combinators for criteria, default to combining:
   #   incomplete AND ( user-specified )
   # unless the "-a" flag is passed.
   # This will replace the filters which are not doing a very good job.

   commandMap[ command ]( taskApi, options, tags, criteria, projectCriteria, words, args )

def getMatchingProjects( taskApi, options, projectCriteria ):
   projects = taskApi.getProjects()
   match = []
   for project in projects:
      for criterion in projectCriteria:
         if not criterion.match( project ):
            break
      else:
         if "debug" in options:
            print( "%s:" % project.shortId, project.apiObject )
         match.append( project )
   return match

def getMatchingProject( taskApi, options, projectCriteria ):
   match = getMatchingProjects( taskApi, options, projectCriteria )
   if len( match ) != 1:
      raise RuntimeError( "Matched %d project(s)" % len( match ) )
   return match[ 0 ]

def doTaskAdd( taskApi, options, tags, criteria, words, args ):
   if not projectCriteria:
      projectCriteria = [ Project.WordMatcher( "inbox" ) ]
   project = getMatchingProject( taskApi, options, projectCriteria )
   task = Task.Task( project, " ".join( words ) )
   taskApi.addTask( task )
   taskApi.invalidateCache( task )

def filterAll( tasks ):
   return tasks

def filterComplete( tasks ):
   #return [ task for task in tasks if task.complete ]
   return tasks

def filterIncomplete( tasks ):
   #return [ task for task in tasks if not task.complete ]
   return tasks

def getMatchingTasks( taskApi, options, tags, criteria, projectCriteria ):
   projects = getMatchingProjects( taskApi, options, projectCriteria )
   tasks = taskApi.getTasks( projects )
   match = []
   for task in tasks:
      for criterion in criteria:
         if not criterion.match( task ):
            break
      else:
         if "debug" in options:
            print( "%s:" % task.shortId, task.apiObject )
         match.append( task )
   return match

def getMatchingTask( taskApi, options, tags, criteria, projectCriteria,
                     completionFilter=filterAll ):
   tasks = getMatchingTasks( taskApi, options, tags, criteria, projectCriteria )
   if len( tasks ) != 1:
      tasks = completionFilter( tasks )
   if len( tasks ) != 1:
      raise RuntimeError( "Matched %d task(s)" % len( tasks ) )
   return tasks[ 0 ]

def printTask( task, options, outfile=sys.stdout ):
   if "debug" in options:
      print( "%s:" % task.shortId, task.apiObject, file=outfile )
   else:
      print( task.lineString(), file=outfile )
      if "verbose" in options and "notes" in task.apiObject:
         print( "  ", task.apiObject[ "notes" ], file=outfile )

def printTasksInProjects( projects, tasks, options, outfile=sys.stdout ):
   if projects is None:
      projects = set( task.project for task in tasks )
   for i, project in enumerate( sorted( projects, key=lambda p: p.title if p.title != "Inbox" else "" ) ):
      if i > 0: print( "", file=outfile )
      print( project, file=outfile )
      # Ensure items with due dates are at the top and in order
      for task in sorted( tasks, key=lambda t: t.apiObject.get( 'due', "ZZZZ" ) ):
         if task.project.title == project.title:
            if "all" in options or not task.complete:
               printTask( task, options, outfile=outfile )

def doTaskList( taskApi, options, tags, criteria, projectCriteria, words, args ):
   tasks = getMatchingTasks( taskApi, options, tags, criteria, projectCriteria )
   printTasksInProjects( None, tasks, options )

def doTaskRename( taskApi, options, tags, criteria, projectCriteria, words, args ):
   task = getMatchingTask( taskApi, options, tags, criteria, projectCriteria,
                           completionFilter=filterIncomplete )
   if not words:
      raise RuntimeError( "No new title given (use -- to complete criteria)" )
   task.title = ' '.join( words )
   taskApi.updateTask( task )
   taskApi.invalidateCache( task )

def doTaskEdit( taskApi, options, tags, criteria, projectCriteria, words, args ):
   task = getMatchingTask( taskApi, options, tags, criteria, projectCriteria,
                           completionFilter=filterIncomplete )
   raise NotImplementedError( "doTasksEdit" )

def doTaskTag( taskApi, options, tags, criteria, projectCriteria, words, args ):
   task = getMatchingTask( taskApi, options, tags, criteria, projectCriteria,
                           completionFilter=filterIncomplete )
   # TODO: Add @TAG criteria, remove @-TAG criteria
   raise NotImplementedError( "doTasksEdit" )

def doTasksOrder( taskApi, options, tags, criteria, projectCriteria, words, args ):
   if options or tags or criteria:
      raise RuntimeError( "order: takes no arguments" )
   projects = getMatchingProjects( taskApi, options, projectCriteria )
   tasks = getMatchingTasks( taskApi, options, tags, criteria, projectCriteria )
   taskById = {}
   for task in tasks:
      taskById[ task.shortId ] = task
   projectByName = {}
   for project in projects:
      projectByName[ project.title ] = project
   taskFilePath = args[ 'tempdir' ] + '/tasks.txt'
   taskFile = open( taskFilePath, 'w')
   with open( taskFilePath, 'w' ) as taskFile:
      printTasksInProjects( projects, tasks, options, outfile=taskFile  )
   subprocess.run( [ os.environ.get( 'EDITOR', 'vi' ), taskFilePath ] )
   toComplete = set()
   toReparent = set()
   with open( taskFilePath, 'r' ) as taskFile:
      project = None
      for line in taskFile:
         match = re.match( r"(t[0-9a-f]+) +\[([ X])\] +", line )
         if match:
            task = taskById[ match[ 1 ] ]
            if match[ 2 ] == 'X':
               toComplete.add( task )
            if task.project.title != project.title:
               toReparent.add( ( task, task.project, project ) )
         # TODO add/remove tags
         elif re.match( r"[A-Za-z0-9_]", line ):
            project = projectByName[ line.strip() ]
   toInvalidate = set()
   for task in toComplete:
      task.complete = True
      taskApi.updateTask( task )
      toInvalidate.add( task )
   for task, fromProject, toProject in toReparent:
      taskApi.moveTask( task, toProject )
      if "due" in task.apiObject:
         print( "Warning: possible loss of time/repeat:", task.lineString() )
      toInvalidate.add( fromProject )
      toInvalidate.add( toProject )
   for item in toInvalidate:
      taskApi.invalidateCache( item )

def doTaskDone( taskApi, options, tags, criteria, projectCriteria, words, args ):
   task = getMatchingTask( taskApi, options, tags, criteria, projectCriteria,
                           completionFilter=filterIncomplete )
   task.complete = True
   taskApi.updateTask( task )
   taskApi.invalidateCache( task )
   printTask( task, options )

def doTaskUndo( taskApi, options, tags, criteria, projectCriteria, words, args ):
   task = getMatchingTask( taskApi, options, tags, criteria, projectCriteria,
                           completionFilter=filterComplete )
   task.complete = False
   taskApi.updateTask( task )
   taskApi.invalidateCache( task )
   printTask( task, options )

def doTaskDelete( taskApi, options, tags, criteria, projectCriteria, words, args ):
   task = getMatchingTask( taskApi, options, tags, criteria, projectCriteria,
                           completionFilter=filterIncomplete )
   printTask( task, options )
   taskApi.invalidateCache( task.project )
   taskApi.deleteTask( task )

def doProjectAdd( taskApi, options, tags, criteria, projectCriteria, words, args ):
   project = Project.Project( ' '.join( words ) )
   taskApi.addProject( project )

def doProjectList( taskApi, options, tags, criteria, projectCriteria, words, args ):
   projects = getMatchingProjects( taskApi, options, projectCriteria )
   for project in projects:
      if "debug" in options:
         print( "%s:" % project.shortId, project.apiObject )
      else:
         print( "%s:" % project.shortId, project )

def doProjectRename( taskApi, options, tags, criteria, projectCriteria, words, args ):
   project = getMatchingProject( taskApi, options, projectCriteria )
   if len( criteria ) < 1:
      raise RuntimeError( "No new name given" )
   project.title = ' '.join( words )
   taskApi.updateProject( project )

def doProjectDelete( taskApi, options, tags, criteria, projectCriteria, words, args ):
   def delProject( project, force ):
      if not force:
         print( "delete %s: %s? [y/N]" % ( project.shortId, project ), file=sys.stderr )
         return
      taskApi.deleteProject( project )
      print( "deleted: %s: %s" % ( project.shortId, project ), file=sys.stderr )

   if not projectCriteria:
      raise RuntimeError( "must specify project id(s) or name(s)" )
   projects = getMatchingProjects( taskApi, options, projectCriteria )
   titles = set( [ p.title for p in projects ] )
   for project in projects:
      if project.title in titles:
         delProject( project, "force" in options )

if __name__ == '__main__':
   program = sys.argv.pop( 0 )
   status = main( sys.argv )
   if not status:
      status = 0
   sys.exit( status )
